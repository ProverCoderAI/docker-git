import type * as CommandExecutor from "@effect/platform/CommandExecutor"
import { ExitCode } from "@effect/platform/CommandExecutor"
import type { PlatformError } from "@effect/platform/Error"
import * as FileSystem from "@effect/platform/FileSystem"
import * as Path from "@effect/platform/Path"
import { Effect } from "effect"

import { defaultProjectsRoot } from "./menu-helpers.js"
import { runCommandCapture, runCommandExitCode, runCommandWithExitCodes } from "../shell/command-runner.js"
import { CommandFailedError } from "../shell/errors.js"

const successExitCode = Number(ExitCode(0))

const gitEnv: Readonly<Record<string, string>> = {
  // Avoid blocking on interactive credential prompts in CI / TUI contexts.
  GIT_TERMINAL_PROMPT: "0"
}

const resolveStateRoot = (
  path: Path.Path,
  cwd: string
): string => path.resolve(defaultProjectsRoot(cwd))

const defaultStateGitignore = [
  "# docker-git state repository",
  "# Generated by docker-git to prevent committing secrets and machine-local files.",
  "",
  "# Secrets (tokens, auth, env)",
  "**/.orch/env/",
  "**/.orch/auth/",
  "",
  "# Logs",
  "**/*.log",
  "",
  "# Machine-local SSH allow-list",
  "authorized_keys",
  ""
].join("\n")

const requiredGitignorePatterns: ReadonlyArray<string> = [
  "**/.orch/env/",
  "**/.orch/auth/"
]

// CHANGE: ensure state repo has a safe .gitignore
// WHY: prevent accidental commit of secrets (tokens, auth, env) when using git-synced state
// QUOTE(ТЗ): "общая память через гит" / "иметь возможность комитить его на гит"
// REF: user-request-2026-02-08-state-gitignore
// SOURCE: n/a
// FORMAT THEOREM: forall root: ensureGitignore(root) -> patternsIncluded(root, required)
// PURITY: SHELL
// EFFECT: Effect<void, PlatformError, FileSystem | Path>
// INVARIANT: preserves existing file content; only appends missing patterns
// COMPLEXITY: O(n) where n = |.gitignore|
const ensureStateGitignore = (
  fs: FileSystem.FileSystem,
  path: Path.Path,
  root: string
): Effect.Effect<void, PlatformError> =>
  Effect.gen(function*(_) {
    const gitignorePath = path.join(root, ".gitignore")
    const exists = yield* _(fs.exists(gitignorePath))
    if (!exists) {
      yield* _(fs.writeFileString(gitignorePath, defaultStateGitignore))
      return
    }

    const stat = yield* _(fs.stat(gitignorePath))
    if (stat.type !== "File") {
      yield* _(Effect.logWarning(`${gitignorePath} exists but is not a file; skipping`))
      return
    }

    const prev = yield* _(fs.readFileString(gitignorePath))
    const prevLines = new Set(prev.replaceAll("\r", "").split("\n").map((l) => l.trimEnd()))
    const missing = requiredGitignorePatterns.filter((p) => !prevLines.has(p))
    if (missing.length === 0) {
      return
    }

    const next = `${prev.trimEnd()}\n\n# Added by docker-git\n${missing.join("\n")}\n`
    yield* _(fs.writeFileString(gitignorePath, next))
  })

// CHANGE: manage docker-git state dir as a git repository
// WHY: allow sharing docker-git state across machines using a private git repo
// QUOTE(ТЗ): "общая память через гит" / "иметь возможность комитить его на гит"
// REF: user-request-2026-02-07-state-repo
// SOURCE: n/a
// FORMAT THEOREM: forall op: state(op) -> deterministic(root)
// PURITY: SHELL
// EFFECT: Effect<void, CommandFailedError | PlatformError, FileSystem | Path | CommandExecutor>
// INVARIANT: never deletes user data; only runs git commands in the state root
// COMPLEXITY: O(command)

export const statePath: Effect.Effect<void, PlatformError, Path.Path> =
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const cwd = process.cwd()
    const root = resolveStateRoot(path, cwd)
    yield* _(Effect.log(root))
  }).pipe(Effect.asVoid)

const git = (
  cwd: string,
  args: ReadonlyArray<string>
): Effect.Effect<void, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  runCommandWithExitCodes(
    { cwd, command: "git", args, env: gitEnv },
    [successExitCode],
    (exitCode) => new CommandFailedError({ command: `git ${args[0] ?? ""}`, exitCode })
  )

const gitExitCode = (
  cwd: string,
  args: ReadonlyArray<string>
): Effect.Effect<number, PlatformError, CommandExecutor.CommandExecutor> =>
  runCommandExitCode({ cwd, command: "git", args, env: gitEnv })

const gitCapture = (
  cwd: string,
  args: ReadonlyArray<string>
): Effect.Effect<string, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  runCommandCapture(
    { cwd, command: "git", args, env: gitEnv },
    [successExitCode],
    (exitCode) => new CommandFailedError({ command: `git ${args[0] ?? ""}`, exitCode })
  )

const isTruthyEnv = (value: string): boolean =>
  value.trim().toLowerCase() === "1" ||
  value.trim().toLowerCase() === "true" ||
  value.trim().toLowerCase() === "yes" ||
  value.trim().toLowerCase() === "on"

const isFalsyEnv = (value: string): boolean =>
  value.trim().toLowerCase() === "0" ||
  value.trim().toLowerCase() === "false" ||
  value.trim().toLowerCase() === "no" ||
  value.trim().toLowerCase() === "off"

const autoSyncEnvKey = "DOCKER_GIT_STATE_AUTO_SYNC"
const autoSyncStrictEnvKey = "DOCKER_GIT_STATE_AUTO_SYNC_STRICT"

const defaultSyncMessage = "chore(state): sync"

const isGitRepo = (root: string) =>
  Effect.map(gitExitCode(root, ["rev-parse", "--is-inside-work-tree"]), (exit) => exit === successExitCode)

const hasOriginRemote = (root: string) =>
  Effect.map(gitExitCode(root, ["remote", "get-url", "origin"]), (exit) => exit === successExitCode)

const commitAllIfNeeded = (
  root: string,
  message: string
): Effect.Effect<void, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    yield* _(git(root, ["add", "-A"]))
    const diffExit = yield* _(gitExitCode(root, ["diff", "--cached", "--quiet"]))
    if (diffExit === successExitCode) {
      return
    }
    yield* _(git(root, ["commit", "-m", message]))
  })

const sanitizeBranchComponent = (value: string): string =>
  value
    .trim()
    .replaceAll(" ", "-")
    .replaceAll(":", "-")
    .replaceAll("..", "-")
    .replaceAll("@{", "-")
    .replaceAll("\\", "-")
    .replaceAll("^", "-")
    .replaceAll("~", "-")

const tryBuildGithubCompareUrl = (
  originUrl: string,
  baseBranch: string,
  headBranch: string
): string | null => {
  const trimmed = originUrl.trim()
  const httpsMatch = trimmed.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+?)(?:\.git)?$/)
  if (httpsMatch) {
    const owner = httpsMatch[1] ?? ""
    const repo = httpsMatch[2] ?? ""
    return `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(headBranch)}?expand=1`
  }

  const sshMatch = trimmed.match(/^git@github\.com:([^/]+)\/(.+?)(?:\.git)?$/)
  if (sshMatch) {
    const owner = sshMatch[1] ?? ""
    const repo = sshMatch[2] ?? ""
    return `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(headBranch)}?expand=1`
  }

  const sshUrlMatch = trimmed.match(/^ssh:\/\/git@github\.com\/([^/]+)\/(.+?)(?:\.git)?$/)
  if (sshUrlMatch) {
    const owner = sshUrlMatch[1] ?? ""
    const repo = sshUrlMatch[2] ?? ""
    return `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(headBranch)}?expand=1`
  }

  return null
}

const rebaseOntoOriginIfPossible = (
  root: string,
  baseBranch: string
): Effect.Effect<"ok" | "skipped" | "conflict", CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    // Ensure we see the latest remote branch tip before attempting to rebase.
    const fetchExit = yield* _(gitExitCode(root, ["fetch", "origin", "--prune"]))
    if (fetchExit !== successExitCode) {
      return yield* _(Effect.fail(new CommandFailedError({ command: "git fetch origin --prune", exitCode: fetchExit })))
    }

    const remoteRef = `refs/remotes/origin/${baseBranch}`
    const hasRemoteBranchExit = yield* _(gitExitCode(root, ["show-ref", "--verify", "--quiet", remoteRef]))
    if (hasRemoteBranchExit !== successExitCode) {
      return "skipped"
    }

    const rebaseExit = yield* _(gitExitCode(root, ["rebase", `origin/${baseBranch}`]))
    if (rebaseExit === successExitCode) {
      return "ok"
    }

    // Best-effort: avoid leaving the repo in a rebase-in-progress state.
    yield* _(gitExitCode(root, ["rebase", "--abort"]))
    return "conflict"
  })

const pushToNewBranch = (
  root: string,
  baseBranch: string
): Effect.Effect<string, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const headShort = yield* _(gitCapture(root, ["rev-parse", "--short", "HEAD"]).pipe(Effect.map((s) => s.trim())))
    const timestamp = yield* _(Effect.sync(() => new Date().toISOString().replaceAll(":", "-").replaceAll(".", "-")))
    const branch = sanitizeBranchComponent(`state-sync/${baseBranch}/${timestamp}-${headShort}`)

    yield* _(git(root, ["push", "origin", `HEAD:refs/heads/${branch}`]))
    return branch
  })

// CHANGE: sync state repo with remote (commit + pull --rebase + push)
// WHY: provide a single command to keep git-synced state up to date across machines
// QUOTE(ТЗ): "иметь команд синхронизации с гит версией"
// REF: user-request-2026-02-08-state-sync
// SOURCE: n/a
// FORMAT THEOREM: forall root: sync(root) -> (local == remote) or typed_error
// PURITY: SHELL
// EFFECT: Effect<void, CommandFailedError | PlatformError, Path | CommandExecutor>
// INVARIANT: never commits ignored files (relies on .gitignore)
// COMPLEXITY: O(git)
export const stateSync = (
  message: string | null
): Effect.Effect<void, CommandFailedError | PlatformError, Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const root = resolveStateRoot(path, process.cwd())

    const repoExit = yield* _(gitExitCode(root, ["rev-parse", "--is-inside-work-tree"]))
    if (repoExit !== successExitCode) {
      yield* _(Effect.logWarning(`State dir is not a git repository: ${root}`))
      yield* _(Effect.logWarning(`Run: docker-git state init --repo-url <url>`))
      return yield* _(
        Effect.fail(
          new CommandFailedError({ command: "git rev-parse --is-inside-work-tree", exitCode: repoExit })
        )
      )
    }

    const originExit = yield* _(gitExitCode(root, ["remote", "get-url", "origin"]))
    if (originExit !== successExitCode) {
      yield* _(Effect.logWarning(`State dir has no origin remote: ${root}`))
      yield* _(Effect.logWarning(`Run: docker-git state init --repo-url <url>`))
      return yield* _(
        Effect.fail(new CommandFailedError({ command: "git remote get-url origin", exitCode: originExit }))
      )
    }

    const commitMessage = message && message.trim().length > 0 ? message.trim() : defaultSyncMessage
    yield* _(commitAllIfNeeded(root, commitMessage))

    const branch = yield* _(gitCapture(root, ["rev-parse", "--abbrev-ref", "HEAD"]).pipe(Effect.map((s) => s.trim())))
    const baseBranch = branch === "HEAD" ? "main" : branch

    const rebaseResult = yield* _(rebaseOntoOriginIfPossible(root, baseBranch))
    if (rebaseResult === "conflict") {
      const prBranch = yield* _(pushToNewBranch(root, baseBranch))
      const originUrl = yield* _(gitCapture(root, ["remote", "get-url", "origin"]).pipe(Effect.map((s) => s.trim())))
      const compareUrl = tryBuildGithubCompareUrl(originUrl, baseBranch, prBranch)

      yield* _(Effect.logWarning(`State sync needs manual merge: pushed changes to branch '${prBranch}'.`))
      if (compareUrl) {
        yield* _(Effect.log(`Open PR: ${compareUrl}`))
      } else {
        yield* _(Effect.log(`Open PR from '${prBranch}' into '${baseBranch}' (origin: ${originUrl}).`))
      }
      return
    }

    const pushExit = yield* _(gitExitCode(root, ["push", "-u", "origin", "HEAD"]))
    if (pushExit === successExitCode) {
      return
    }

    // Race / divergence: fall back to pushing a PR branch instead of failing the sync.
    const prBranch = yield* _(pushToNewBranch(root, baseBranch))
    const originUrl = yield* _(gitCapture(root, ["remote", "get-url", "origin"]).pipe(Effect.map((s) => s.trim())))
    const compareUrl = tryBuildGithubCompareUrl(originUrl, baseBranch, prBranch)
    yield* _(Effect.logWarning(`State push failed (exit ${pushExit}); pushed changes to branch '${prBranch}'.`))
    if (compareUrl) {
      yield* _(Effect.log(`Open PR: ${compareUrl}`))
      return
    }
    yield* _(Effect.log(`Open PR from '${prBranch}' into '${baseBranch}' (origin: ${originUrl}).`))
  }).pipe(Effect.asVoid)

const isAutoSyncEnabled = (
  envValue: string | undefined,
  hasRemote: boolean
): boolean => {
  if (envValue === undefined) {
    return hasRemote
  }
  if (envValue.trim().length === 0) {
    return hasRemote
  }
  if (isFalsyEnv(envValue)) {
    return false
  }
  if (isTruthyEnv(envValue)) {
    return true
  }
  // Non-empty values default to enabled.
  return true
}

// CHANGE: automatically sync state after docker-git operations
// WHY: keep state repo always pushed when containers/projects are added
// QUOTE(ТЗ): "любое обновление .docker-git папки комитило и пушило её на гит"
// REF: user-request-2026-02-08-auto-sync
// SOURCE: n/a
// FORMAT THEOREM: forall op: updates(op) -> eventually_synced(op)
// PURITY: SHELL
// EFFECT: Effect<void, never, Path | CommandExecutor>
// INVARIANT: best-effort; never fails the main operation
// COMPLEXITY: O(git)
export const autoSyncState = (
  message: string
): Effect.Effect<void, never, Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const root = resolveStateRoot(path, process.cwd())

    const repoOk = yield* _(isGitRepo(root))
    if (!repoOk) {
      return
    }

    const originOk = yield* _(hasOriginRemote(root))
    const enabled = isAutoSyncEnabled(process.env[autoSyncEnvKey], originOk)
    if (!enabled) {
      return
    }

    const strictValue = process.env[autoSyncStrictEnvKey]
    const strict = strictValue !== undefined && strictValue.trim().length > 0 ? isTruthyEnv(strictValue) : false
    const effect = stateSync(message)
    if (strict) {
      yield* _(effect)
      return
    }
    yield* _(
      effect.pipe(
        Effect.catchAll((error) =>
          Effect.logWarning(
            `State auto-sync failed: ${error._tag === "CommandFailedError"
              ? `${error.command} (exit ${error.exitCode})`
              : String(error)}`
          )
        )
      )
    )
  }).pipe(
    Effect.catchAll((error) => Effect.logWarning(`State auto-sync failed: ${String(error)}`)),
    Effect.asVoid
  )

export const stateInit = (
  input: {
    readonly repoUrl: string
    readonly repoRef: string
  }
): Effect.Effect<void, CommandFailedError | PlatformError, FileSystem.FileSystem | Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const fs = yield* _(FileSystem.FileSystem)
    const path = yield* _(Path.Path)
    const cwd = process.cwd()
    const root = resolveStateRoot(path, cwd)

    yield* _(fs.makeDirectory(root, { recursive: true }))

    const gitDir = path.join(root, ".git")
    const hasGit = yield* _(fs.exists(gitDir))
    if (!hasGit) {
      const entries = yield* _(fs.readDirectory(root))
      if (entries.length === 0) {
        const cloneWithBranch = ["clone", "--branch", input.repoRef, input.repoUrl, root]
        const cloneBranchExit = yield* _(
          runCommandExitCode({ cwd: root, command: "git", args: cloneWithBranch, env: gitEnv })
        )
        if (cloneBranchExit !== successExitCode) {
          // Empty remotes (no branch yet) and remotes without the requested branch can fail here.
          // Fall back to cloning the default branch so we can still set up the repo and create the branch locally.
          yield* _(
            Effect.logWarning(
              `git clone --branch ${input.repoRef} failed (exit ${cloneBranchExit}); retrying without --branch`
            )
          )
          const cloneDefault = ["clone", input.repoUrl, root]
          const cloneDefaultExit = yield* _(
            runCommandExitCode({ cwd: root, command: "git", args: cloneDefault, env: gitEnv })
          )
          if (cloneDefaultExit !== successExitCode) {
            return yield* _(Effect.fail(new CommandFailedError({ command: "git clone", exitCode: cloneDefaultExit })))
          }
        }
        yield* _(Effect.log(`State dir cloned: ${root}`))
      } else {
        yield* _(git(root, ["init"]))
      }
    }

    const setUrlExit = yield* _(gitExitCode(root, ["remote", "set-url", "origin", input.repoUrl]))
    if (setUrlExit !== successExitCode) {
      yield* _(git(root, ["remote", "add", "origin", input.repoUrl]))
    }

    // Best-effort: ensure the local branch exists and can be tracked later.
    const checkoutExit = yield* _(gitExitCode(root, ["checkout", "-B", input.repoRef]))
    if (checkoutExit !== successExitCode) {
      yield* _(Effect.logWarning(`git checkout -B ${input.repoRef} failed (exit ${checkoutExit})`))
    }

    yield* _(ensureStateGitignore(fs, path, root))
    yield* _(Effect.log(`State dir ready: ${root}`))
    yield* _(Effect.log(`Remote: ${input.repoUrl}`))
  }).pipe(Effect.asVoid)

export const stateStatus = Effect.gen(function*(_) {
  const path = yield* _(Path.Path)
  const root = resolveStateRoot(path, process.cwd())
  const output = yield* _(gitCapture(root, ["status", "-sb", "--porcelain=v1"]))
  yield* _(Effect.log(output.trim().length > 0 ? output.trimEnd() : "(clean)"))
}).pipe(Effect.asVoid)

export const statePull = Effect.gen(function*(_) {
  const path = yield* _(Path.Path)
  const root = resolveStateRoot(path, process.cwd())
  yield* _(git(root, ["pull", "--rebase"]))
}).pipe(Effect.asVoid)

export const statePush = Effect.gen(function*(_) {
  const path = yield* _(Path.Path)
  const root = resolveStateRoot(path, process.cwd())
  yield* _(git(root, ["push", "-u", "origin", "HEAD"]))
}).pipe(Effect.asVoid)

export const stateCommit = (
  message: string
): Effect.Effect<void, CommandFailedError | PlatformError, Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const root = resolveStateRoot(path, process.cwd())

    yield* _(git(root, ["add", "-A"]))
    const diffExit = yield* _(gitExitCode(root, ["diff", "--cached", "--quiet"]))

    if (diffExit === successExitCode) {
      yield* _(Effect.log("Nothing to commit."))
      return
    }

    yield* _(git(root, ["commit", "-m", message]))
  }).pipe(Effect.asVoid)
