import type * as CommandExecutor from "@effect/platform/CommandExecutor"
import { ExitCode } from "@effect/platform/CommandExecutor"
import type { PlatformError } from "@effect/platform/Error"
import * as FileSystem from "@effect/platform/FileSystem"
import * as Path from "@effect/platform/Path"
import { Effect } from "effect"

import { defaultProjectsRoot } from "./menu-helpers.js"
import { parseEnvEntries } from "./env-file.js"
import { normalizeLegacyStateProjects } from "./state-normalize.js"
import { runCommandCapture, runCommandExitCode, runCommandWithExitCodes } from "../shell/command-runner.js"
import { CommandFailedError } from "../shell/errors.js"

const successExitCode = Number(ExitCode(0))

const gitBaseEnv: Readonly<Record<string, string>> = {
  // Avoid blocking on interactive credential prompts in CI / TUI contexts.
  GIT_TERMINAL_PROMPT: "0"
}

const githubTokenKey = "GITHUB_TOKEN"

const resolveStateRoot = (
  path: Path.Path,
  cwd: string
): string => path.resolve(defaultProjectsRoot(cwd))

const defaultStateGitignore = [
  "# docker-git state repository",
  "# Generated by docker-git to prevent committing secrets and machine-local files.",
  "",
  "# Secrets (tokens, auth, env)",
  "**/.orch/env/",
  "**/.orch/auth/",
  "",
  "# Logs",
  "**/*.log",
  "",
  "# Machine-local SSH allow-list",
  "authorized_keys",
  ""
].join("\n")

const requiredGitignorePatterns: ReadonlyArray<string> = [
  "**/.orch/env/",
  "**/.orch/auth/"
]

// CHANGE: ensure state repo has a safe .gitignore
// WHY: prevent accidental commit of secrets (tokens, auth, env) when using git-synced state
// QUOTE(ТЗ): "общая память через гит" / "иметь возможность комитить его на гит"
// REF: user-request-2026-02-08-state-gitignore
// SOURCE: n/a
// FORMAT THEOREM: forall root: ensureGitignore(root) -> patternsIncluded(root, required)
// PURITY: SHELL
// EFFECT: Effect<void, PlatformError, FileSystem | Path>
// INVARIANT: preserves existing file content; only appends missing patterns
// COMPLEXITY: O(n) where n = |.gitignore|
const ensureStateGitignore = (
  fs: FileSystem.FileSystem,
  path: Path.Path,
  root: string
): Effect.Effect<void, PlatformError> =>
  Effect.gen(function*(_) {
    const gitignorePath = path.join(root, ".gitignore")
    const exists = yield* _(fs.exists(gitignorePath))
    if (!exists) {
      yield* _(fs.writeFileString(gitignorePath, defaultStateGitignore))
      return
    }

    const stat = yield* _(fs.stat(gitignorePath))
    if (stat.type !== "File") {
      yield* _(Effect.logWarning(`${gitignorePath} exists but is not a file; skipping`))
      return
    }

    const prev = yield* _(fs.readFileString(gitignorePath))
    const prevLines = new Set(prev.replaceAll("\r", "").split("\n").map((l) => l.trimEnd()))
    const missing = requiredGitignorePatterns.filter((p) => !prevLines.has(p))
    if (missing.length === 0) {
      return
    }

    const next = `${prev.trimEnd()}\n\n# Added by docker-git\n${missing.join("\n")}\n`
    yield* _(fs.writeFileString(gitignorePath, next))
  })

// CHANGE: manage docker-git state dir as a git repository
// WHY: allow sharing docker-git state across machines using a private git repo
// QUOTE(ТЗ): "общая память через гит" / "иметь возможность комитить его на гит"
// REF: user-request-2026-02-07-state-repo
// SOURCE: n/a
// FORMAT THEOREM: forall op: state(op) -> deterministic(root)
// PURITY: SHELL
// EFFECT: Effect<void, CommandFailedError | PlatformError, FileSystem | Path | CommandExecutor>
// INVARIANT: never deletes user data; only runs git commands in the state root
// COMPLEXITY: O(command)

export const statePath: Effect.Effect<void, PlatformError, Path.Path> =
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const cwd = process.cwd()
    const root = resolveStateRoot(path, cwd)
    yield* _(Effect.log(root))
  }).pipe(Effect.asVoid)

const git = (
  cwd: string,
  args: ReadonlyArray<string>,
  env: Readonly<Record<string, string | undefined>> = gitBaseEnv
): Effect.Effect<void, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  runCommandWithExitCodes(
    { cwd, command: "git", args, env },
    [successExitCode],
    (exitCode) => new CommandFailedError({ command: `git ${args[0] ?? ""}`, exitCode })
  )

const gitExitCode = (
  cwd: string,
  args: ReadonlyArray<string>,
  env: Readonly<Record<string, string | undefined>> = gitBaseEnv
): Effect.Effect<number, PlatformError, CommandExecutor.CommandExecutor> =>
  runCommandExitCode({ cwd, command: "git", args, env })

const gitCapture = (
  cwd: string,
  args: ReadonlyArray<string>,
  env: Readonly<Record<string, string | undefined>> = gitBaseEnv
): Effect.Effect<string, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  runCommandCapture(
    { cwd, command: "git", args, env },
    [successExitCode],
    (exitCode) => new CommandFailedError({ command: `git ${args[0] ?? ""}`, exitCode })
  )

const isTruthyEnv = (value: string): boolean =>
  value.trim().toLowerCase() === "1" ||
  value.trim().toLowerCase() === "true" ||
  value.trim().toLowerCase() === "yes" ||
  value.trim().toLowerCase() === "on"

const isFalsyEnv = (value: string): boolean =>
  value.trim().toLowerCase() === "0" ||
  value.trim().toLowerCase() === "false" ||
  value.trim().toLowerCase() === "no" ||
  value.trim().toLowerCase() === "off"

const autoSyncEnvKey = "DOCKER_GIT_STATE_AUTO_SYNC"
const autoSyncStrictEnvKey = "DOCKER_GIT_STATE_AUTO_SYNC_STRICT"

const defaultSyncMessage = "chore(state): sync"

const isGitRepo = (root: string) =>
  Effect.map(gitExitCode(root, ["rev-parse", "--is-inside-work-tree"]), (exit) => exit === successExitCode)

const hasOriginRemote = (root: string) =>
  Effect.map(gitExitCode(root, ["remote", "get-url", "origin"]), (exit) => exit === successExitCode)

const commitAllIfNeeded = (
  root: string,
  message: string,
  env: Readonly<Record<string, string | undefined>>
): Effect.Effect<void, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    yield* _(git(root, ["add", "-A"], env))
    const diffExit = yield* _(gitExitCode(root, ["diff", "--cached", "--quiet"], env))
    if (diffExit === successExitCode) {
      return
    }
    yield* _(git(root, ["commit", "-m", message], env))
  })

const sanitizeBranchComponent = (value: string): string =>
  value
    .trim()
    .replaceAll(" ", "-")
    .replaceAll(":", "-")
    .replaceAll("..", "-")
    .replaceAll("@{", "-")
    .replaceAll("\\", "-")
    .replaceAll("^", "-")
    .replaceAll("~", "-")

const tryBuildGithubCompareUrl = (
  originUrl: string,
  baseBranch: string,
  headBranch: string
): string | null => {
  const trimmed = originUrl.trim()
  const httpsMatch = trimmed.match(/^https:\/\/github\.com\/([^/]+)\/([^/]+?)(?:\.git)?$/)
  if (httpsMatch) {
    const owner = httpsMatch[1] ?? ""
    const repo = httpsMatch[2] ?? ""
    return `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(headBranch)}?expand=1`
  }

  const sshMatch = trimmed.match(/^git@github\.com:([^/]+)\/(.+?)(?:\.git)?$/)
  if (sshMatch) {
    const owner = sshMatch[1] ?? ""
    const repo = sshMatch[2] ?? ""
    return `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(headBranch)}?expand=1`
  }

  const sshUrlMatch = trimmed.match(/^ssh:\/\/git@github\.com\/([^/]+)\/(.+?)(?:\.git)?$/)
  if (sshUrlMatch) {
    const owner = sshUrlMatch[1] ?? ""
    const repo = sshUrlMatch[2] ?? ""
    return `https://github.com/${owner}/${repo}/compare/${encodeURIComponent(baseBranch)}...${encodeURIComponent(headBranch)}?expand=1`
  }

  return null
}

const rebaseOntoOriginIfPossible = (
  root: string,
  baseBranch: string,
  env: Readonly<Record<string, string | undefined>>
): Effect.Effect<"ok" | "skipped" | "conflict", CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    // Ensure we see the latest remote branch tip before attempting to rebase.
    const fetchExit = yield* _(gitExitCode(root, ["fetch", "origin", "--prune"], env))
    if (fetchExit !== successExitCode) {
      return yield* _(Effect.fail(new CommandFailedError({ command: "git fetch origin --prune", exitCode: fetchExit })))
    }

    const remoteRef = `refs/remotes/origin/${baseBranch}`
    const hasRemoteBranchExit = yield* _(gitExitCode(root, ["show-ref", "--verify", "--quiet", remoteRef], env))
    if (hasRemoteBranchExit !== successExitCode) {
      return "skipped"
    }

    const rebaseExit = yield* _(gitExitCode(root, ["rebase", `origin/${baseBranch}`], env))
    if (rebaseExit === successExitCode) {
      return "ok"
    }

    // Best-effort: avoid leaving the repo in a rebase-in-progress state.
    yield* _(gitExitCode(root, ["rebase", "--abort"], env))
    return "conflict"
  })

const pushToNewBranch = (
  root: string,
  baseBranch: string,
  env: Readonly<Record<string, string | undefined>>
): Effect.Effect<string, CommandFailedError | PlatformError, CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const headShort = yield* _(
      gitCapture(root, ["rev-parse", "--short", "HEAD"], env).pipe(Effect.map((s) => s.trim()))
    )
    const timestamp = yield* _(Effect.sync(() => new Date().toISOString().replaceAll(":", "-").replaceAll(".", "-")))
    const branch = sanitizeBranchComponent(`state-sync/${baseBranch}/${timestamp}-${headShort}`)

    yield* _(git(root, ["push", "origin", `HEAD:refs/heads/${branch}`], env))
    return branch
  })

const isGithubHttpsRemote = (url: string): boolean => /^https:\/\/github\.com\//.test(url.trim())

// CHANGE: resolve GitHub token for git HTTPS auth (env > state global.env)
// WHY: enable non-interactive git push/pull for private state repositories
// QUOTE(ТЗ): "Он должен был сделать пуш на гит что бы держать синхронизацию данных"
// REF: user-request-2026-02-09-state-push-auth
// SOURCE: n/a
// FORMAT THEOREM: forall root: token(root) -> auth_possible(root)
// PURITY: SHELL
// EFFECT: Effect<string | null, PlatformError, FileSystem | Path>
// INVARIANT: never logs the token
// COMPLEXITY: O(n) where n = |global.env|
const resolveGithubToken = (
  fs: FileSystem.FileSystem,
  path: Path.Path,
  root: string
): Effect.Effect<string | null, PlatformError> =>
  Effect.gen(function*(_) {
    const fromEnv = process.env["GITHUB_TOKEN"]?.trim() ?? process.env["GH_TOKEN"]?.trim() ?? ""
    if (fromEnv.length > 0) {
      return fromEnv
    }

    const envPath = path.join(root, ".orch", "env", "global.env")
    const exists = yield* _(fs.exists(envPath))
    if (!exists) {
      return null
    }

    const text = yield* _(fs.readFileString(envPath))
    const entries = parseEnvEntries(text)
    const direct = entries.find((e) => e.key === githubTokenKey)?.value?.trim() ?? ""
    if (direct.length > 0) {
      return direct
    }

    const labeled = entries.find((e) => e.key.startsWith("GITHUB_TOKEN__"))?.value?.trim() ?? ""
    return labeled.length > 0 ? labeled : null
  })

const withGithubAskpassEnv = <A, E, R>(
  token: string,
  use: (env: Readonly<Record<string, string | undefined>>) => Effect.Effect<A, E, R>
): Effect.Effect<A, E | PlatformError, FileSystem.FileSystem | R> =>
  Effect.scoped(
    Effect.gen(function*(_) {
      const fs = yield* _(FileSystem.FileSystem)
      const askpassPath = yield* _(fs.makeTempFileScoped({ prefix: "docker-git-askpass-" }))
      const contents = [
        "#!/bin/sh",
        "case \"$1\" in",
        "  *Username*) echo \"x-access-token\" ;;",
        "  *Password*) echo \"${DOCKER_GIT_GITHUB_TOKEN}\" ;;",
        "  *) echo \"${DOCKER_GIT_GITHUB_TOKEN}\" ;;",
        "esac",
        ""
      ].join("\n")
      yield* _(fs.writeFileString(askpassPath, contents))
      yield* _(fs.chmod(askpassPath, 0o700))
      const env: Readonly<Record<string, string | undefined>> = {
        ...gitBaseEnv,
        DOCKER_GIT_GITHUB_TOKEN: token,
        GIT_ASKPASS: askpassPath,
        GIT_ASKPASS_REQUIRE: "force"
      }
      return yield* _(use(env))
    })
  )

// CHANGE: sync state repo with remote (commit + pull --rebase + push)
// WHY: provide a single command to keep git-synced state up to date across machines
// QUOTE(ТЗ): "иметь команд синхронизации с гит версией"
// REF: user-request-2026-02-08-state-sync
// SOURCE: n/a
// FORMAT THEOREM: forall root: sync(root) -> (local == remote) or typed_error
// PURITY: SHELL
// EFFECT: Effect<void, CommandFailedError | PlatformError, Path | CommandExecutor>
// INVARIANT: never commits ignored files (relies on .gitignore)
// COMPLEXITY: O(git)
export const stateSync = (
  message: string | null
): Effect.Effect<
  void,
  CommandFailedError | PlatformError,
  FileSystem.FileSystem | Path.Path | CommandExecutor.CommandExecutor
> =>
  Effect.gen(function*(_) {
    const fs = yield* _(FileSystem.FileSystem)
    const path = yield* _(Path.Path)
    const root = resolveStateRoot(path, process.cwd())
    const baseEnv = gitBaseEnv

    const repoExit = yield* _(gitExitCode(root, ["rev-parse", "--is-inside-work-tree"], baseEnv))
    if (repoExit !== successExitCode) {
      yield* _(Effect.logWarning(`State dir is not a git repository: ${root}`))
      yield* _(Effect.logWarning(`Run: docker-git state init --repo-url <url>`))
      return yield* _(
        Effect.fail(
          new CommandFailedError({ command: "git rev-parse --is-inside-work-tree", exitCode: repoExit })
        )
      )
    }

    const originUrlExit = yield* _(gitExitCode(root, ["remote", "get-url", "origin"], baseEnv))
    if (originUrlExit !== successExitCode) {
      yield* _(Effect.logWarning(`State dir has no origin remote: ${root}`))
      yield* _(Effect.logWarning(`Run: docker-git state init --repo-url <url>`))
      return yield* _(
        Effect.fail(new CommandFailedError({ command: "git remote get-url origin", exitCode: originUrlExit }))
      )
    }
    const originUrl = yield* _(gitCapture(root, ["remote", "get-url", "origin"], baseEnv).pipe(Effect.map((s) => s.trim())))
    const token = yield* _(resolveGithubToken(fs, path, root))
    const envEffect =
      token && token.length > 0 && isGithubHttpsRemote(originUrl)
        ? withGithubAskpassEnv(
          token,
          (env) =>
            Effect.gen(function*(__) {
              yield* __(normalizeLegacyStateProjects(root))
              const commitMessage = message && message.trim().length > 0 ? message.trim() : defaultSyncMessage
              yield* __(commitAllIfNeeded(root, commitMessage, env))

              const branch = yield* __(
                gitCapture(root, ["rev-parse", "--abbrev-ref", "HEAD"], env).pipe(Effect.map((s) => s.trim()))
              )
              const baseBranch = branch === "HEAD" ? "main" : branch

              const rebaseResult = yield* __(rebaseOntoOriginIfPossible(root, baseBranch, env))
              if (rebaseResult === "conflict") {
                const prBranch = yield* __(pushToNewBranch(root, baseBranch, env))
                const compareUrl = tryBuildGithubCompareUrl(originUrl, baseBranch, prBranch)

                yield* __(Effect.logWarning(`State sync needs manual merge: pushed changes to branch '${prBranch}'.`))
                if (compareUrl) {
                  yield* __(Effect.log(`Open PR: ${compareUrl}`))
                } else {
                  yield* __(Effect.log(`Open PR from '${prBranch}' into '${baseBranch}' (origin: ${originUrl}).`))
                }
                return
              }

              const pushExit = yield* __(gitExitCode(root, ["push", "-u", "origin", "HEAD"], env))
              if (pushExit === successExitCode) {
                return
              }

              const prBranch = yield* __(pushToNewBranch(root, baseBranch, env))
              const compareUrl = tryBuildGithubCompareUrl(originUrl, baseBranch, prBranch)
              yield* __(
                Effect.logWarning(`State push failed (exit ${pushExit}); pushed changes to branch '${prBranch}'.`)
              )
              if (compareUrl) {
                yield* __(Effect.log(`Open PR: ${compareUrl}`))
                return
              }
              yield* __(Effect.log(`Open PR from '${prBranch}' into '${baseBranch}' (origin: ${originUrl}).`))
            })
        )
        : Effect.gen(function*(__) {
          yield* __(normalizeLegacyStateProjects(root))
          const commitMessage = message && message.trim().length > 0 ? message.trim() : defaultSyncMessage
          yield* __(commitAllIfNeeded(root, commitMessage, baseEnv))

          const branch = yield* __(
            gitCapture(root, ["rev-parse", "--abbrev-ref", "HEAD"], baseEnv).pipe(Effect.map((s) => s.trim()))
          )
          const baseBranch = branch === "HEAD" ? "main" : branch

          const rebaseResult = yield* __(rebaseOntoOriginIfPossible(root, baseBranch, baseEnv))
          if (rebaseResult === "conflict") {
            const prBranch = yield* __(pushToNewBranch(root, baseBranch, baseEnv))
            const compareUrl = tryBuildGithubCompareUrl(originUrl, baseBranch, prBranch)

            yield* __(Effect.logWarning(`State sync needs manual merge: pushed changes to branch '${prBranch}'.`))
            if (compareUrl) {
              yield* __(Effect.log(`Open PR: ${compareUrl}`))
            } else {
              yield* __(Effect.log(`Open PR from '${prBranch}' into '${baseBranch}' (origin: ${originUrl}).`))
            }
            return
          }

          const pushExit = yield* __(gitExitCode(root, ["push", "-u", "origin", "HEAD"], baseEnv))
          if (pushExit === successExitCode) {
            return
          }

          const prBranch = yield* __(pushToNewBranch(root, baseBranch, baseEnv))
          const compareUrl = tryBuildGithubCompareUrl(originUrl, baseBranch, prBranch)
          yield* __(Effect.logWarning(`State push failed (exit ${pushExit}); pushed changes to branch '${prBranch}'.`))
          if (compareUrl) {
            yield* __(Effect.log(`Open PR: ${compareUrl}`))
            return
          }
          yield* __(Effect.log(`Open PR from '${prBranch}' into '${baseBranch}' (origin: ${originUrl}).`))
        })

    yield* _(envEffect)
  }).pipe(Effect.asVoid)

const isAutoSyncEnabled = (
  envValue: string | undefined,
  hasRemote: boolean
): boolean => {
  if (envValue === undefined) {
    return hasRemote
  }
  if (envValue.trim().length === 0) {
    return hasRemote
  }
  if (isFalsyEnv(envValue)) {
    return false
  }
  if (isTruthyEnv(envValue)) {
    return true
  }
  // Non-empty values default to enabled.
  return true
}

// CHANGE: automatically sync state after docker-git operations
// WHY: keep state repo always pushed when containers/projects are added
// QUOTE(ТЗ): "любое обновление .docker-git папки комитило и пушило её на гит"
// REF: user-request-2026-02-08-auto-sync
// SOURCE: n/a
// FORMAT THEOREM: forall op: updates(op) -> eventually_synced(op)
// PURITY: SHELL
// EFFECT: Effect<void, never, Path | CommandExecutor>
// INVARIANT: best-effort; never fails the main operation
// COMPLEXITY: O(git)
export const autoSyncState = (
  message: string
): Effect.Effect<void, never, FileSystem.FileSystem | Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const root = resolveStateRoot(path, process.cwd())

    const repoOk = yield* _(isGitRepo(root))
    if (!repoOk) {
      return
    }

    const originOk = yield* _(hasOriginRemote(root))
    const enabled = isAutoSyncEnabled(process.env[autoSyncEnvKey], originOk)
    if (!enabled) {
      return
    }

    const strictValue = process.env[autoSyncStrictEnvKey]
    const strict = strictValue !== undefined && strictValue.trim().length > 0 ? isTruthyEnv(strictValue) : false
    const effect = stateSync(message)
    if (strict) {
      yield* _(effect)
      return
    }
    yield* _(
      effect.pipe(
        Effect.catchAll((error) =>
          Effect.logWarning(
            `State auto-sync failed: ${error._tag === "CommandFailedError"
              ? `${error.command} (exit ${error.exitCode})`
              : String(error)}`
          )
        )
      )
    )
  }).pipe(
    Effect.catchAll((error) => Effect.logWarning(`State auto-sync failed: ${String(error)}`)),
    Effect.asVoid
  )

export const stateInit = (
  input: {
    readonly repoUrl: string
    readonly repoRef: string
  }
): Effect.Effect<void, CommandFailedError | PlatformError, FileSystem.FileSystem | Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const fs = yield* _(FileSystem.FileSystem)
    const path = yield* _(Path.Path)
    const cwd = process.cwd()
    const root = resolveStateRoot(path, cwd)

    yield* _(fs.makeDirectory(root, { recursive: true }))

    const gitDir = path.join(root, ".git")
    const hasGit = yield* _(fs.exists(gitDir))
    if (!hasGit) {
      const entries = yield* _(fs.readDirectory(root))
      if (entries.length === 0) {
        const cloneWithBranch = ["clone", "--branch", input.repoRef, input.repoUrl, root]
        const cloneBranchExit = yield* _(
          runCommandExitCode({ cwd: root, command: "git", args: cloneWithBranch, env: gitBaseEnv })
        )
        if (cloneBranchExit !== successExitCode) {
          // Empty remotes (no branch yet) and remotes without the requested branch can fail here.
          // Fall back to cloning the default branch so we can still set up the repo and create the branch locally.
          yield* _(
            Effect.logWarning(
              `git clone --branch ${input.repoRef} failed (exit ${cloneBranchExit}); retrying without --branch`
            )
          )
          const cloneDefault = ["clone", input.repoUrl, root]
          const cloneDefaultExit = yield* _(
            runCommandExitCode({ cwd: root, command: "git", args: cloneDefault, env: gitBaseEnv })
          )
          if (cloneDefaultExit !== successExitCode) {
            return yield* _(Effect.fail(new CommandFailedError({ command: "git clone", exitCode: cloneDefaultExit })))
          }
        }
        yield* _(Effect.log(`State dir cloned: ${root}`))
      } else {
        yield* _(git(root, ["init"], gitBaseEnv))
      }
    }

    const setUrlExit = yield* _(gitExitCode(root, ["remote", "set-url", "origin", input.repoUrl], gitBaseEnv))
    if (setUrlExit !== successExitCode) {
      yield* _(git(root, ["remote", "add", "origin", input.repoUrl], gitBaseEnv))
    }

    // Best-effort: ensure the local branch exists and can be tracked later.
    const checkoutExit = yield* _(gitExitCode(root, ["checkout", "-B", input.repoRef], gitBaseEnv))
    if (checkoutExit !== successExitCode) {
      yield* _(Effect.logWarning(`git checkout -B ${input.repoRef} failed (exit ${checkoutExit})`))
    }

    yield* _(ensureStateGitignore(fs, path, root))
    yield* _(Effect.log(`State dir ready: ${root}`))
    yield* _(Effect.log(`Remote: ${input.repoUrl}`))
  }).pipe(Effect.asVoid)

export const stateStatus = Effect.gen(function*(_) {
  const path = yield* _(Path.Path)
  const root = resolveStateRoot(path, process.cwd())
  const output = yield* _(gitCapture(root, ["status", "-sb", "--porcelain=v1"], gitBaseEnv))
  yield* _(Effect.log(output.trim().length > 0 ? output.trimEnd() : "(clean)"))
}).pipe(Effect.asVoid)

export const statePull = Effect.gen(function*(_) {
  const fs = yield* _(FileSystem.FileSystem)
  const path = yield* _(Path.Path)
  const root = resolveStateRoot(path, process.cwd())
  const originUrlExit = yield* _(gitExitCode(root, ["remote", "get-url", "origin"], gitBaseEnv))
  if (originUrlExit !== successExitCode) {
    yield* _(git(root, ["pull", "--rebase"], gitBaseEnv))
    return
  }
  const originUrl = yield* _(gitCapture(root, ["remote", "get-url", "origin"], gitBaseEnv).pipe(Effect.map((s) => s.trim())))
  const token = yield* _(resolveGithubToken(fs, path, root))
  const effect =
    token && token.length > 0 && isGithubHttpsRemote(originUrl)
      ? withGithubAskpassEnv(token, (env) => git(root, ["pull", "--rebase"], env))
      : git(root, ["pull", "--rebase"], gitBaseEnv)
  yield* _(effect)
}).pipe(Effect.asVoid)

export const statePush = Effect.gen(function*(_) {
  const fs = yield* _(FileSystem.FileSystem)
  const path = yield* _(Path.Path)
  const root = resolveStateRoot(path, process.cwd())
  const originUrlExit = yield* _(gitExitCode(root, ["remote", "get-url", "origin"], gitBaseEnv))
  if (originUrlExit !== successExitCode) {
    yield* _(git(root, ["push", "-u", "origin", "HEAD"], gitBaseEnv))
    return
  }
  const originUrl = yield* _(gitCapture(root, ["remote", "get-url", "origin"], gitBaseEnv).pipe(Effect.map((s) => s.trim())))
  const token = yield* _(resolveGithubToken(fs, path, root))
  const effect =
    token && token.length > 0 && isGithubHttpsRemote(originUrl)
      ? withGithubAskpassEnv(token, (env) => git(root, ["push", "-u", "origin", "HEAD"], env))
      : git(root, ["push", "-u", "origin", "HEAD"], gitBaseEnv)
  yield* _(effect)
}).pipe(Effect.asVoid)

export const stateCommit = (
  message: string
): Effect.Effect<void, CommandFailedError | PlatformError, Path.Path | CommandExecutor.CommandExecutor> =>
  Effect.gen(function*(_) {
    const path = yield* _(Path.Path)
    const root = resolveStateRoot(path, process.cwd())

    yield* _(git(root, ["add", "-A"], gitBaseEnv))
    const diffExit = yield* _(gitExitCode(root, ["diff", "--cached", "--quiet"], gitBaseEnv))

    if (diffExit === successExitCode) {
      yield* _(Effect.log("Nothing to commit."))
      return
    }

    yield* _(git(root, ["commit", "-m", message], gitBaseEnv))
  }).pipe(Effect.asVoid)
